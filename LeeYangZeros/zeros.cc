/* Flow analysis through the generating-function zeros method. */

/* The input is a file 'events.dat' 
   following the structure of the file generated by 'generator.cc', i.e.: 
   - first, the number of events; 
   - then, for each event, the (detected) multiplicity, 
   and for each particle the transverse momentum (in MeV) and the azimuth
   (in radians). */

/* The program then reconstructs integrated elliptic flow (V2) and then 
   differential elliptic (v2) and "hexadecupolar" (v4) flows. */

/* The results are stored in the output file 'zeros.txt' */

/* Throughout the program, references are made to the papers:
   [A]: R.S.Bhalerao, N.Borghini, J.-Y.Ollitrault, Nucl. Phys. A 727 (2003) 373
        [nucl-th/0310016];
   [B]: N.Borghini, R.S.Bhalerao, J.-Y.Ollitrault, J. Phys. G 30 (2004) S1213
        [nucl-th/0402053]. */
#include <iostream>
#include <math.h>
#include <stdio.h>
#include <complex.h>
#include <sys/time.h>
#include <fstream>
#include <TStopwatch.h>
#include <TChain.h>
#include <TFile.h>
#include <TMath.h>
#include <TVector3.h>
#include <TH2F.h>
#include <TH1.h>
#include <TProfile.h>
#include <TProfile2D.h>
#include <TDatabasePDG.h>

using namespace std;
/* */

#define Pi (2.*acos(0.))
#define sqr(x) ((x)*(x))
#define rootJ0 2.4048256  /* First zero of the modified Bessel function J0 */
#define J1rootJ0 0.519147 /* J1(rootJ0) */
#define J2rootJ0 0.431755 /* J2(rootJ0) */
#define MAX_TRACKS 10000
/* PARAMETERS USED IN THE RECONSTRUCTION */
/* kr*kt is the number of points at which one computes the 
   generating function 
   kt possible values for the angle 
   kr possible values for the radius */ 
#define kt 5
#define kr 100

#define vmax 0.101 /* maximal possible integrated flow value */
#define vstep 0.001
#define vmin 0.001 /* minimal possible integrated flow value: check that vmin + kr*vstep = vmax!! */

#define Nbins 9 /* number of bins for differential flow. Check that it is consistent with the number in distributions.cc! */
const double centrality = 15;
/* */
const double maxpt = 3.; // max pt
const double minpt = 0.2;  // min pt
const double eta_cut = 1.5;
double CentB(double bimp)
{
  // Hard coded centrality defenition
  // based on the impact parameter
  double fcent;
  if (bimp < 2.91)
    fcent = 2.5; // 0-5%
  else if (bimp < 4.18)
    fcent = 7.5; // 5-10%
  else if (bimp < 6.01)
    fcent = 15.; // 10-20%
  else if (bimp < 7.37)
    fcent = 25.; // 20-30%
  else if (bimp < 8.52)
    fcent = 35.; // 30-40%
  else if (bimp < 9.57)
    fcent = 45.; // 40-50%
  else if (bimp < 10.55)
    fcent = 55.; // 50-60%
  else if (bimp < 11.46)
    fcent = 65.; // 60-70%
  else if (bimp < 12.31)
    fcent = 75.; // 70-80%
  else
    fcent = -1;
  return fcent;
}

int GetCentBin(double cent)
{
  if (cent == -1)
    return -1;
  if (cent == 2.5)
    return 0;
  if (cent == 7.5)
    return 1;
  if (cent == 15.)
    return 2;
  if (cent == 25.)
    return 3;
  if (cent == 35.)
    return 4;
  if (cent == 45.)
    return 5;
  if (cent == 55.)
    return 6;
  if (cent == 65.)
    return 7;
  if (cent == 75.)
    return 8;
  return -1;
}

double BesselJ0(double x)
{
  double temp=1., xn=1.;
  long n, Nmax;

  Nmax=int(floor(2.*x)+4);
  for (n=1;n<Nmax;n++)
  {
    xn*=(-sqr(x/2./((float) n)));
    temp+=xn;
  }
  return temp;
}

FILE *input,*data,*output,*plotVint,*plotvdiff;

void zeros(TString inputFileName, TString outputFileName)
{ /* main() */
  /* Variable declaration */

  const complex<double> i(0,1);

  int neve = 0; /* Number of events */
  int rmult;  /* Detected multiplicity in an event */
  double rpmult[Nbins]; /* Detected multiplicity per bin */
  double rmultmean; /* Average detected multiplicity */
  float phi, pT; /* particle azimuth and transverse momentum */
  int binpT;

  double arg[kt]; /* theta values */
  double RZ[kr]; /* tabulation points for each theta value */

  /* Generating functions evaluated at the tabulation points: 
     - g2[k1][k2] is the generating function g in the harmonic 2, 
       for theta=arg[k1], evaluated at RZ[k2];
     - G2[][] is its average over events;
     - modG2sq is the squared modulus of the averaged G2. */
  complex<double> g2[kt][kr], G2[kt][kr];
  double modG2sq[kt][kr];

  double w2[Nbins]; /* weights */

  /* Event flow vectors, useful for the computation of statistical errors:
     - Q2 is the (weighted) flow vector in each event in harmonic n=2;
     - Q2mean is its average over events;
     - modQ2sqmean is the average over event of the squared modulus |Q2|^2. */
  complex<double> Q2, Q2mean; 
  double modQ2sqmean;

  /* r02[] are the values of RZ which minimize the functions mod2Gsq[kt][kr]; 
     these are the r0^theta of Refs.[A,B]. */
  double r02[kt]; 

  /* Values of the generating function g2 at the minimum of the average G2 */
  complex<double> g2r0[kt]; 

  complex<double> dlng2_dz[kt], dG2_dz[kt];
  complex<double> dlng2_dw2[kt][Nbins], dG2_dw2[kt][Nbins]; 
  complex<double> basenum42[kt][Nbins], num42[kt][Nbins];

  /* V2[] are the reconstructed integrated flow values for each angle arg[k1],
     i.e. the various V2^theta{infty} in the notations of Refs.[A,B]; 
     V2mean is their average value, denoted by V2{infty} in the Refs.
     vd22[][], vd42[][] are the differential flows for each angle, 
       in a given bin;
     vd22mean[], vd42mean[] are their average values. */
  double V2[kt], V2mean;
  double vd22[kt][Nbins], vd22mean[Nbins], vd42[kt][Nbins], vd42mean[Nbins];
  double vd22av, vd42av;
  const double bin_pT[Nbins+1]={0.2,0.4,0.6,0.8,1.,1.2,1.5,1.8,2.5,3.};
  double chi2, err2[kt], err2mean;
  double err22[kt][Nbins], err22mean[Nbins], err42[kt][Nbins], err42mean[Nbins];

  /* For simulations only: parameters of the event generation */
  double Vmax, Vstep;

  int k;
  double temp;

  struct timeval Time;
  int debut, fin;

  /* Initializations */
  gettimeofday (&Time, 0);
  debut=Time.tv_sec;
  rmult = 313;
  // data=fopen("inputdata.dat","r");
  // fscanf(data, "%i %i\n", &k, &rmult); 
  // fclose(data);
  Vmax=vmax*rmult;
  Vstep=vstep*rmult;

  for(int k1=0; k1<kt; k1++)
  { /* Loop over angles */
    arg[k1]=((float) k1)*Pi/(kt-1.); 
    /* kt arguments equally spaced between 0 and Pi (radians).
       Please note that arg[] in this program is n*theta the Refs. */
    for(int k2=0; k2<kr; k2++)
    { 
      RZ[k2]=rootJ0/(Vmax-Vstep*k2);
      // RZ[k2]=(float)k2/kr;

      // if (k1==0) cout << RZ[k2] << " ";
      /* The moduli of the interpolation points are chosen so that they 
         correspond to equally spaced (with step vstep) flow values. */

      G2[k1][k2]=0.;
      /* Initialization of the average generating functions */ 
    } 
    // if (k1==0) cout << endl;
  } /* End of loop over angles */

  /* In this program, rmultmean is used to estimate statistical errors. */
  rmultmean=0.;
  for(int bin=0;bin<Nbins;bin++) 
  {
    rpmult[bin]=0.;
    w2[bin]=1.; /* unit weights for the moment... */
  }

  /* Averages of the (complex!) event flow vectors and their squared moduli. */
  Q2mean=0.;
  modQ2sqmean=0.;

  /* Scan of the data */
  printf("Reading the data file to analyse flow\n");
  // input=fopen("events.dat","r");
  // fscanf(input, "%i\n", &neve); /* Read the number of events */
  // printf("----------\nNumber of events in the run: %i\n", neve);

  // Configure input information
  TChain *chain = new TChain("mctree");
  std::ifstream file(inputFileName.Data());
  std::string line;
  while (std::getline(file, line))
  {
    chain->Add(line.c_str());
  }
  Float_t bimp;
  Float_t phi2;
  Float_t phi3;
  Float_t ecc2;
  Float_t ecc3;
  Int_t npart;
  Int_t nh;
  Float_t momx[MAX_TRACKS];   //[nh]
  Float_t momy[MAX_TRACKS];   //[nh]
  Float_t momz[MAX_TRACKS];   //[nh]
  Float_t ene[MAX_TRACKS];    //[nh]
  Int_t hid[MAX_TRACKS];      //[nh]
  Int_t pdg[MAX_TRACKS];      //[nh]
  Short_t charge[MAX_TRACKS]; //[nh]

  // List of branches
  TBranch *b_bimp;   //!
  TBranch *b_phi2;   //!
  TBranch *b_phi3;   //!
  TBranch *b_ecc2;   //!
  TBranch *b_ecc3;   //!
  TBranch *b_npart;  //!
  TBranch *b_nh;     //!
  TBranch *b_momx;   //!
  TBranch *b_momy;   //!
  TBranch *b_momz;   //!
  TBranch *b_ene;    //!
  TBranch *b_hid;    //!
  TBranch *b_pdg;    //!
  TBranch *b_charge; //!

  chain->SetBranchAddress("bimp", &bimp, &b_bimp);
  chain->SetBranchAddress("phi2", &phi2, &b_phi2);
  chain->SetBranchAddress("phi3", &phi3, &b_phi3);
  chain->SetBranchAddress("ecc2", &ecc2, &b_ecc2);
  chain->SetBranchAddress("ecc3", &ecc3, &b_ecc3);
  chain->SetBranchAddress("npart", &npart, &b_npart);
  chain->SetBranchAddress("nh", &nh, &b_nh);
  chain->SetBranchAddress("momx", momx, &b_momx);
  chain->SetBranchAddress("momy", momy, &b_momy);
  chain->SetBranchAddress("momz", momz, &b_momz);
  chain->SetBranchAddress("ene", ene, &b_ene);
  chain->SetBranchAddress("hid", hid, &b_hid);
  chain->SetBranchAddress("pdg", pdg, &b_pdg);
  chain->SetBranchAddress("charge", charge, &b_charge);

  output=fopen("zeros1020.txt","w");
  fprintf(output,
	  "FLOW ANALYSIS THROUGH THE ZEROS OF THE GENERATING FUNCTION\n\n");
  fprintf(output, "Parameter in the analysis:\n"); 
  fprintf(output, "%i values of theta\n", kt); 
  // fprintf(output,"\nAvailable statistics:\n  number of events = %i\n", neve);
  fprintf(output, "Centrality:%.f-%.f%%\n", centrality-5,centrality+5); 
  /* RECONSTRUCTION OF INTEGRATED FLOW FROM THE GENERATING FUNCTION */
  printf("\n 1. Reconstruction of integrated flow\n");
  /* */
  int n_entries = chain->GetEntries();
  for(int ne=0; ne<n_entries; ne++) 
  { /* Loop over events */
    if (floor((ne+1.)*10./n_entries)==((ne+1.)*10./n_entries))
      printf("%.f percent of events processed\n",(ne+1.)*100./n_entries);
    chain->GetEntry(ne);
    // fscanf(input, "%i", &rmult); /* Read the event multiplicity */
    // rmultmean+=((float) rmult); /* and compute the average multiplicity. */
    rmult = 0;
    /* Initialization of the generating functions gn[k1][k2]. */
    for(int k1=0; k1<kt; k1++) for(int k2=0; k2<kr; k2++) g2[k1][k2]=1.;
    /* Initialization of the event flow vector */
    Q2=0.;
    double cent = CentB(bimp); if (cent != centrality) continue;
    for(int np=0; np<nh; np++) /* Loop over the event particles */
    {
      // fscanf(input,"%f %f", &pT, &phi); /* Read the particle momentum & azimuth;
		  //                        the former is useless for the moment */
      // binpT=pTbin(pT); /* Useless since unit weights... */
      binpT = 0;   
      TVector3 vect(momx[np], momy[np], momz[np]);
      double pt = vect.Pt();
      double eta = vect.Eta();
      double phi = vect.Phi();
      // track cuts
      if (pt < minpt || pt > maxpt || fabs(eta) > eta_cut)
        continue; // track selection
      auto particle = (TParticlePDG *)TDatabasePDG::Instance()->GetParticle(pdg[np]);
      if (!particle)
        continue;
      double charge = 1. / 3. * particle->Charge();
      if (charge == 0)
        continue;

      /* For each value of theta and r, compute the generating functions g2, g4
         using Eq.(3) of Ref.[B] */
      for(int k1=0; k1<kt; k1++) /* Loop over theta values */
      { 
        temp=w2[binpT]*cos(2.*phi-arg[k1]);
        for(int k2=0; k2<kr; k2++) g2[k1][k2]*=(1.+i*RZ[k2]*temp);
      }/* End of the loop over theta values */
      rmult++;  
      /* Compute the event flow vectors: Ref.[B], Eq.(4), with Q = Qx + i Qy. */
      Q2+=(w2[binpT]*exp(2.*i*((double) phi)));
    } /* End of the loop over particles */
    if (rmult!=0)
    {  
    for(int k1=0; k1<kt; k1++) for(int k2=0; k2<kr; k2++) 
      /* Compute the generating functions G2[k1], G4[k1], 
         averaged over events at the points RZ for each angle theta. */
      G2[k1][k2]+=g2[k1][k2];
    rmultmean+=((float) rmult); /* and compute the average multiplicity. */
    Q2mean+=Q2;     /* Compute the average event flow vector... */ 
    modQ2sqmean+=sqr(abs(Q2)); /* and the average of its square modulus */
    neve++;
    }
  } /* End of the loop over events */
  // fclose(input);
  rmultmean/=neve; /* Average detected particle multiplicity */

  modQ2sqmean/=neve; /* Average square moduli of the event flow vectors */

  gettimeofday (&Time, 0);
  fin=Time.tv_sec;
  printf("All events read, elapsed time=%d s\n", fin-debut);
  printf("Mean detected particle multiplicity <M>=%G\n", rmultmean);
  fprintf(output,"  mean detected particle multiplicity <M>=%G\n\n", rmultmean);
  fprintf(output,"  Minimum measurable flow v=%.3g\n\n", 
	  rootJ0/sqrt(2.*rmultmean*log(0.5*neve))); 
  /* v = j_{01}/Sqrt(2M ln(Neve/2)), cf. Ref.[A], Eq.(80) */

  /* RECONSTRUCTION OF INTEGRATED FLOW */
  V2mean=0.;
  for(int k1=0; k1<kt; k1++) 
  { /* Loop over theta angles */
    for(int k2=0;k2<kr;k2++) 
    {
      modG2sq[k1][k2]=sqr(abs(G2[k1][k2])/neve);
      if (k1 == 0) std::cout << modG2sq[k1][k2] <<" "; 
    }  
    if (k1 == 0) std::cout << endl;
    /* Compute the squared moduli of G2, G4 at each point */
    
    /* Looking for the first minimum of |G2|^2 */
    k=0;
    while (modG2sq[k1][k]>modG2sq[k1][k+1]) k++;
    /* Interpolate the value of V2[k1], see footnote 3 in Ref.[A],
       and derive the corresponding position of the first zero of G2 */
    V2[k1]=Vmax-Vstep*(k+(modG2sq[k1][k-1]-modG2sq[k1][k+1])/2./
	   (modG2sq[k1][k-1]-2.*modG2sq[k1][k]+modG2sq[k1][k+1]));
    r02[k1]=rootJ0/V2[k1];
    V2mean+=V2[k1]; /* Average V2 */
  } /* End of the loop over theta angles */

  V2mean/=((float) kt); /* Average V2 */
  /* Compute the resolution parameters chi, using Eqs.(59),(62) of Ref.[A] */
  chi2=V2mean/
    sqrt(modQ2sqmean-sqr(real(Q2mean)/neve)-sqr(imag(Q2mean)/neve)-sqr(V2mean));

  plotVint=fopen("plots_Vint1020.grf","w");
  for(int k1=0; k1<kt; k1++) 
  { /* Loop over theta angles */
    /* Compute the statistical error bar on the estimates Vn^theta{infty}, 
       using Eq.(90) of Ref.[A] = Eq.(8) of Ref.[B]. */
    err2[k1]=V2[k1]*sqrt((exp(-sqr(rootJ0/chi2)/2.)*BesselJ0(2.*rootJ0)+
			  exp(sqr(rootJ0/chi2)/2.))/2./neve)/rootJ0/J1rootJ0;
    fprintf(plotVint, "%.3g\t%.4g\t%.4g\n", arg[k1], V2[k1]/rmultmean, 
      err2[k1]/rmultmean);
  }
  fclose(plotVint);

  /* Integrated elliptic flow v2 */
  fprintf(output,"INTEGRATED ELLIPTIC FLOW:");
  
  temp=0.;
  for(int k1=0; k1<kt; k1++) 
    /* Loop over the angles of the interpolation points,     
       to compute the statistical error bar on the average estimate V2{infty}, 
       with the help of Eqs.(89) of Ref.[A]. */
    temp+=exp(sqr(rootJ0/chi2)*cos(arg[k1])/2.)*
      BesselJ0(2.*rootJ0*sin(arg[k1]/2.))+
      exp(-sqr(rootJ0/chi2)*cos(arg[k1])/2.)*
      BesselJ0(2.*rootJ0*cos(arg[k1]/2.));
  err2mean=V2mean*sqrt(temp/2./neve/kt)/rootJ0/J1rootJ0;
  fprintf(output, " V2/<M>=%.3g +/- %.3g", V2mean/rmultmean, 
    err2mean/rmultmean);

  /* */
  /* RECONSTRUCTION OF DIFFERENTIAL FLOW FROM THE GENERATING FUNCTION */
  /* */
  /* Initializations */
  
  for(int bin=0; bin<Nbins; bin++) vd22mean[bin]=vd42mean[bin]=0.;
  for(int k1=0; k1<kt; k1++) 
  {
    dG2_dz[k1]=0.;
    for(int bin=0; bin<Nbins; bin++) dG2_dw2[k1][bin]=num42[k1][bin]=0.;
  }

  // input=fopen("events.dat","r");
  // fscanf(input,"%i\n",&neve); /* Read the number of events */
  printf("\n 2. Reconstruction of differential flow\n");

  for(long ne=0; ne<n_entries; ne++) 
  { /* Loop over events */
    if (floor((ne+1.)*10./n_entries)==((ne+1.)*10./n_entries))
      printf("%.f percent of events processed\n",(ne+1.)*100./n_entries);
    chain->GetEntry(ne);
    double cent = CentB(bimp); if (cent != centrality) continue;
    /* Initializations */
    for(int k1=0; k1<kt; k1++)
    {
      g2r0[k1]=1.;
      dlng2_dz[k1]=0.;
      for(int bin=0; bin<Nbins; bin++) dlng2_dw2[k1][bin]=basenum42[k1][bin]=0.;
    }
    rmult = 0;
    // fscanf(input,"%i",&rmult); /* Read the event multiplicity */
    for(long np=0; np<nh; np++) /* Loop over the event particles */
    {
      TVector3 vect(momx[np], momy[np], momz[np]);
      double pt = vect.Pt();
      double eta = vect.Eta();
      double phi = vect.Phi();
      // track cuts
      if (pt < minpt || pt > maxpt || fabs(eta) > eta_cut)
        continue; // track selection
      auto particle = (TParticlePDG *)TDatabasePDG::Instance()->GetParticle(pdg[np]);
      if (!particle)
        continue;
      double charge = 1. / 3. * particle->Charge();
      if (charge == 0)
        continue;
      /* Assign a bin to the particle according to its transverse momentum, 
         and increment the number of detected particles in that bin. */
      int binpT = -1;
      for(int j=0; j<Nbins;j++) {if (pt>=bin_pT[j] && pt<bin_pT[j+1]) {binpT = j;}}
      rpmult[binpT]+=1.; 
      rmult++;
      for(int k1=0; k1<kt; k1++)
      {
        /* For each value of theta, compute the generating functions g2, g4
           at the first minimum r0n of Gn: 
           the corresponding quantity, g^theta(ir0^theta), appears in both the 
           numerator and denominator of Eq.(9) in Ref.[B]. */
        temp=w2[binpT]*cos(2.*phi-arg[k1]);
        g2r0[k1]*=(1.+i*r02[k1]*temp);
        /* Compute the sum over all particles that appears in the denominator 
           of Eq.(9) in Ref.[B]. */
        dlng2_dz[k1]+=(temp/(1.+i*r02[k1]*temp)); 
        /* Compute the ratio that stands in the numerator of Eq.(9) in Ref.[B].
           This ratio should be summed over all differential particles in a bin,
           and then (later) divided by the total number of such particles, to 
           perform the corresponding average (denoted by < >_psi in Ref.[B]. */
        dlng2_dw2[k1][binpT]+=(cos(2.*phi-arg[k1])/(1.+i*r02[k1]*temp)); 
        basenum42[k1][binpT]+=(cos(4.*phi-2.*arg[k1])/(1.+i*r02[k1]*temp)); 
      } /* End of the loop over theta angles */
    } /* End of the loop over particles */
    if (rmult!=0){
    for(int k1=0; k1<kt; k1++) /* loop over theta values */
    { /* Compute the average over events in the denominator of Eq.(9) 
         in Ref.[B] */
      dG2_dz[k1]+=dlng2_dz[k1]*g2r0[k1];

      for(int bin=0; bin<Nbins; bin++) /* loop over differential bins */
      { /* Compute the average over differential particles in each bin 
           in the numerator of Eq.(9) in Ref.[B] */
        dG2_dw2[k1][bin]+=dlng2_dw2[k1][bin]*g2r0[k1];
        num42[k1][bin]+=basenum42[k1][bin]*g2r0[k1];
      } /* loop over differential bins */
    } /* end of the loop over theta values */
    }
  } /* End of the loop over events */
  // fclose(input);

  for(int k1=0; k1<kt; k1++) 
  { /* Average over events of the denominator of Eq.(9) in Ref.[B] */
    dG2_dz[k1]/=neve;

    for(int bin=0; bin<Nbins; bin++)
    { /* Average over differential particles of the numerator of Eq.(9) */
      dG2_dw2[k1][bin]/=rpmult[bin];
      num42[k1][bin]/=rpmult[bin];

      /* Computation of the differential flow value v'2/2 in each bin... */
      vd22[k1][bin]=V2[k1]*real(dG2_dw2[k1][bin]/dG2_dz[k1]);
      /* ...and of the corresponding statistical error: Ref.[B], Eq.(10) */
      err22[k1][bin]=sqrt((exp(sqr(rootJ0/chi2)/2.) - 
        exp(-sqr(rootJ0/chi2)/2.)*BesselJ0(2.*rootJ0))/rpmult[bin])/
        2./J1rootJ0; /* standard error on v'2/2^theta */
      vd22mean[bin]+=vd22[k1][bin];

      /* Computation of the differential flow value v'4/2 in each bin... */
      vd42[k1][bin]=V2[k1]*(J1rootJ0/J2rootJ0)*
        real(num42[k1][bin]/(i*dG2_dz[k1])); /* Note the i in the denominator */
      err42[k1][bin]=sqrt((exp(sqr(rootJ0/chi2)/2.) + 
        exp(-sqr(rootJ0/chi2)/2.)*BesselJ0(2.*rootJ0))/rpmult[bin])/
        2./J2rootJ0; /* standard error on v'4/2^theta */
      vd42mean[bin]+=vd42[k1][bin];
    }
  }
  
  for(int bin=0; bin<Nbins; bin++)
  {
    /* Average (over angles) differential flow values */
    vd22mean[bin]/=kt;
    vd42mean[bin]/=kt;
    /* Average (over events) number of particles per bin */
    rpmult[bin]/=neve;
  }

  /* Computation of statistical error bars on the average estimates */
  temp=0.;
  for(int k1=0; k1<kt; k1++) 
    /* Loop over the theta angles, to compute the statistical error */
    temp+=(exp(sqr(rootJ0/chi2)*cos(arg[k1])/2.)*
      BesselJ0(2.*rootJ0*sin(arg[k1]/2.)) -
      exp(-sqr(rootJ0/chi2)*cos(arg[k1])/2.)*
      BesselJ0(2.*rootJ0*cos(arg[k1]/2.)))*cos(arg[k1]);
  for(int bin=0; bin<Nbins; bin++)
    err22mean[bin]=sqrt(temp/rpmult[bin]/neve/kt)/2./J1rootJ0;

  temp=0.;
  for(int k1=0; k1<kt; k1++) 
    /* Loop over the theta angles, to compute the statistical error */
    temp+=(exp(sqr(rootJ0/chi2)*cos(arg[k1])/2.)*
      BesselJ0(2.*rootJ0*sin(arg[k1]/2.))+
      exp(-sqr(rootJ0/chi2)*cos(arg[k1])/2.)*
      BesselJ0(2.*rootJ0*cos(arg[k1]/2.)))*cos(2.*arg[k1]);
  for(int bin=0; bin<Nbins; bin++)
    err42mean[bin]=sqrt(temp/rpmult[bin]/neve/kt)/2./J2rootJ0;

  vd22av=vd42av=0.;
  plotvdiff=fopen("plot_vdiff-zeros1020.grf","w");
  fprintf(output,"\n\nDIFFERENTIAL FLOW\n\n");
  for(int bin=0; bin<Nbins; bin++)
  {
    if (rpmult[bin]>0)
    { /* compute the average (over pT) v2 and v4 */
      vd22av+=rpmult[bin]*vd22mean[bin]; 
      vd42av+=rpmult[bin]*vd42mean[bin];
    }
    fprintf(output," . bin %i: average detected multiplicity <M'>=%G\n", bin,
	   rpmult[bin]);
    fprintf(output,"   v2=%.3g +/- %.3g,", vd22mean[bin], err22mean[bin]);
    fprintf(output,"   v4=%.3g +/- %.3g\n", vd42mean[bin], err42mean[bin]);
    fprintf(plotvdiff, "%i  %.4g  %.4g  %.4g %.4g  %.4g\n", bin, rpmult[bin], 
	    vd22mean[bin], err22mean[bin], vd42mean[bin], err42mean[bin]);
  }
  vd22av/=rmultmean;
  vd42av/=rmultmean;
  fprintf(output, "<v2>=%.3g,  <v4>=%.3g\n", vd22av, vd42av);
  fprintf(output, "chi2=%.3g\n", chi2);
  gettimeofday (&Time, 0);
  fin=Time.tv_sec;
  printf("All events read, elapsed time=%d s\n",fin-debut);
  fprintf(output,"\nEnd of the analysis, elapsed time=%d s\n",fin-debut);

  fclose(output);
  fclose(plotvdiff);
  
} /* main() */

